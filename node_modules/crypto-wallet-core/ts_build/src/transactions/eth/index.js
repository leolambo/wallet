"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ethers_1 = require("ethers");
var web3_1 = __importDefault(require("web3"));
var abi_1 = require("../erc20/abi");
var utils = require('web3-utils');
var toBN = web3_1.default.utils.toBN;
var ETHTxProvider = (function () {
    function ETHTxProvider() {
    }
    ETHTxProvider.prototype.create = function (params) {
        var recipients = params.recipients, nonce = params.nonce, gasPrice = params.gasPrice, gasLimit = params.gasLimit, network = params.network, contractAddress = params.contractAddress;
        var data = params.data;
        var to;
        var amount;
        if (recipients.length > 1) {
            if (!contractAddress) {
                throw new Error('Multiple recipients requires use of multi-send contract, please specify contractAddress');
            }
            var addresses = [];
            var amounts = [];
            amount = toBN(0);
            for (var _i = 0, recipients_1 = recipients; _i < recipients_1.length; _i++) {
                var recipient = recipients_1[_i];
                addresses.push(recipient.address);
                amounts.push(toBN(recipient.amount));
                amount = amount.add(toBN(recipient.amount));
            }
            var multisendContract = this.getMultiSendContract(contractAddress);
            data = data || multisendContract.methods.sendEth(addresses, amounts).encodeABI();
            to = contractAddress;
        }
        else {
            to = recipients[0].address;
            amount = recipients[0].amount;
        }
        var chainId = params.chainId;
        chainId = chainId || this.getChainId(network);
        var txData = {
            nonce: utils.toHex(nonce),
            gasLimit: utils.toHex(gasLimit),
            gasPrice: utils.toHex(gasPrice),
            to: to,
            data: data,
            value: utils.toHex(amount),
            chainId: chainId
        };
        return ethers_1.ethers.utils.serializeTransaction(txData);
    };
    ETHTxProvider.prototype.getMultiSendContract = function (tokenContractAddress) {
        var web3 = new web3_1.default();
        return new web3.eth.Contract(abi_1.MULTISENDAbi, tokenContractAddress);
    };
    ETHTxProvider.prototype.getChainId = function (network) {
        var chainId = 1;
        switch (network) {
            case 'testnet':
            case 'goerli':
                chainId = 5;
                break;
            case 'kovan':
                chainId = 42;
                break;
            case 'ropsten':
                chainId = 3;
                break;
            case 'rinkeby':
                chainId = 4;
                break;
            case 'regtest':
                chainId = 1337;
                break;
            default:
                chainId = 1;
                break;
        }
        return chainId;
    };
    ETHTxProvider.prototype.getSignatureObject = function (params) {
        var tx = params.tx, key = params.key;
        var k = key.privKey;
        if (k.substr(0, 2) != '0x') {
            k = '0x' + k;
        }
        var signingKey = new ethers_1.ethers.utils.SigningKey(k);
        var signDigest = signingKey.signDigest.bind(signingKey);
        return signDigest(ethers_1.ethers.utils.keccak256(tx));
    };
    ETHTxProvider.prototype.getSignature = function (params) {
        var signatureHex = ethers_1.ethers.utils.joinSignature(this.getSignatureObject(params));
        return signatureHex;
    };
    ETHTxProvider.prototype.getHash = function (params) {
        var tx = params.tx;
        return ethers_1.ethers.utils.parseTransaction(tx).hash;
    };
    ETHTxProvider.prototype.applySignature = function (params) {
        var tx = params.tx, signature = params.signature;
        var parsedTx = ethers_1.ethers.utils.parseTransaction(tx);
        var nonce = parsedTx.nonce, gasPrice = parsedTx.gasPrice, gasLimit = parsedTx.gasLimit, to = parsedTx.to, value = parsedTx.value, data = parsedTx.data, chainId = parsedTx.chainId;
        var txData = { nonce: nonce, gasPrice: gasPrice, gasLimit: gasLimit, to: to, value: value, data: data, chainId: chainId };
        if (typeof signature == 'string') {
            signature = ethers_1.ethers.utils.splitSignature(signature);
        }
        var signedTx = ethers_1.ethers.utils.serializeTransaction(txData, signature);
        var parsedTxSigned = ethers_1.ethers.utils.parseTransaction(signedTx);
        if (!parsedTxSigned.hash) {
            throw new Error('Signature invalid');
        }
        return signedTx;
    };
    ETHTxProvider.prototype.sign = function (params) {
        var tx = params.tx, key = params.key;
        var signature = this.getSignatureObject({ tx: tx, key: key });
        return this.applySignature({ tx: tx, signature: signature });
    };
    return ETHTxProvider;
}());
exports.ETHTxProvider = ETHTxProvider;
//# sourceMappingURL=index.js.map